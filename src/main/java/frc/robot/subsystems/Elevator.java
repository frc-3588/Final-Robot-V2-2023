// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.Constants.ElevatorConstants;
// import frc.robot.commands.*;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax.ControlType;

import com.revrobotics.SparkMaxLimitSwitch;
import com.revrobotics.CANSparkMax.IdleMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.SparkMaxLimitSwitch.Type;

import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Elevator extends SubsystemBase {

    private final CANSparkMax leftMotor;
    private final CANSparkMax rightMotor;
    private final MotorControllerGroup motorControllerGroup;

    private SparkMaxPIDController leftPIDController;
    private SparkMaxPIDController rightPIDController;

    private double kP = 0.0;
    private double kI = 0.0;
    private double kD = 0.0;
    private double kIz = 0.0;
    private double kFF = 0.0;
    private double kMaxOutput = 0.75;
    private double kMinOutput = -0.75;
    // private int kMaxRPM = 5700;

    private RelativeEncoder leftEncoder;
    private RelativeEncoder rightEncoder;

    private double rotations = 0;

    // private double height = 0.0d;
    // private double elevatorMaxHeight = 0.0d;
    private double setPoint;

    private SparkMaxLimitSwitch reversedLimitSwitch;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Elevator() {

        leftMotor = new CANSparkMax(9, MotorType.kBrushless);
        rightMotor = new CANSparkMax(6, MotorType.kBrushless);
        motorControllerGroup = new MotorControllerGroup(leftMotor, rightMotor);

        // leftPIDController = leftMotor.getPIDController();
        // rightPIDController = rightMotor.getPIDController();

        rightMotor.setInverted(true);

        // leftEncoder = leftMotor.getEncoder();
        // rightEncoder = rightMotor.getEncoder();

        // leftEncoder.setPosition(0.0);
        // rightEncoder.setPosition(0.0);

        // leftPIDController.setP(kP);
        // leftPIDController.setI(kI);
        // leftPIDController.setD(kD);
        // leftPIDController.setIZone(kIz);
        // leftPIDController.setFF(kFF);
        // leftPIDController.setOutputRange(kMinOutput, kMaxOutput);

        // rightPIDController.setP(kP);
        // rightPIDController.setI(kI);
        // rightPIDController.setD(kD);
        // rightPIDController.setIZone(kIz);
        // rightPIDController.setFF(kFF);
        // rightPIDController.setOutputRange(kMinOutput, kMaxOutput);

        // rightPIDController.setSmartMotionAllowedClosedLoopError(allowedErr, 0);
        // leftPIDController.setSmartMotionAllowedClosedLoopError(allowedErr, 0);

        rightMotor.setIdleMode(IdleMode.kBrake);
        leftMotor.setIdleMode(IdleMode.kBrake);

        // rightMotor.burnFlash();
        // leftMotor.burnFlash();

        // leftEncoder.setPositionFactor(M_PI * 3/4);

        // // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // SmartDashboard.putNumber("Elevator P Gain", kP);
        // SmartDashboard.putNumber("Elevator I Gain", kI);
        // SmartDashboard.putNumber("Elevator D Gain", kD);
        // SmartDashboard.putNumber("Elevator I Zone", kIz);
        // SmartDashboard.putNumber("Elevator Feed Forward", kFF);
        // SmartDashboard.putNumber("Elevator Max Output", kMaxOutput);
        // SmartDashboard.putNumber("Elevator Min Output", kMinOutput);

    }


    @Override
    public void periodic() {

        // double p = SmartDashboard.getNumber("Elevator P Gain", 0);
        // double i = SmartDashboard.getNumber("Elevator I Gain", 0);
        // double d = SmartDashboard.getNumber("Elevator D Gain", 0);
        // double iz = SmartDashboard.getNumber("Elevator I Zone", 0);
        // double ff = SmartDashboard.getNumber("Elevator Feed Forward", 0);
        // double max = SmartDashboard.getNumber("Elevator Max Output", 0);
        // double min = SmartDashboard.getNumber("Elevator Min Output", 0);

        // if((p != kP)){
        //     leftPIDController.setP(p);
        //     rightPIDController.setP(p);

        //     kP = p;
        // }
        // if((i != kI)){
        //     leftPIDController.setI(i);
        //     rightPIDController.setI(i);

        //     kI = i;
        // }
        // if((d != kD)){
        //     leftPIDController.setD(d);
        //     rightPIDController.setD(d);

        //     kD = d;
        // }
        // if((ff != kFF)){
        //     leftPIDController.setFF(ff);
        //     rightPIDController.setFF(ff);

        //     kFF = ff;
        // }
        // if((iz != kIz)){
        //     leftPIDController.setIZone(iz);
        //     rightPIDController.setIZone(iz);

        //     kIz = iz;
        // }

        //  if((max != kMaxOutput) || min != kMinOutput ){
        //     leftPIDController.setOutputRange(min, max);
        //     rightPIDController.setOutputRange(min, max);

        //     kMinOutput = min;
        //     kMaxOutput = max;
        //  }

        //  SmartDashboard.putNumber("Left Elevator Rotations Graph", leftEncoder.getPosition());
        //  SmartDashboard.putNumber("Left Elevator Rotations", leftEncoder.getPosition());

        //  SmartDashboard.putNumber("Right Elevator Rotations Graph", rightEncoder.getPosition());
        //  SmartDashboard.putNumber("Right Elevator Rotations", rightEncoder.getPosition());

        //  rotations = SmartDashboard.getNumber("Elevator Rotations", rotations);
        //  leftPIDController.setReference(rotations, ControlType.kPosition);
        //  rightPIDController.setReference(rotations, ControlType.kPosition);

         






        // SmartDashboard.putBoolean("LeftLimSwitch", leftLimitSwitch());
        // SmartDashboard.putNumber("Left Motor Position", leftEncoder.getPosition());


        // This method will be called once per scheduler run

    //    SmartDashboard.getNumber("Elevator P Gain", rightPIDController.getP());



    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // measure wheel distance per rotation

    // private void setElevatorRefrences(double setHeight) {
    // leftPIDController.setReference(setHeight, CANSparkMax.ControlType.kPosition);
    // rightPIDController.setReference(setHeight,
    // CANSparkMax.ControlType.kPosition);
    // leftPIDController.setReference(setHeight, CANSparkMax.ControlType.kPosition);
    // rightPIDController.setReference(setHeight,
    // CANSparkMax.ControlType.kPosition);
    // }

    // public void setElevatorHeight(double newHeight) {
    // if (newHeight >= elevatorMaxHeight) {
    // setElevatorRefrences(elevatorMaxHeight);
    // } else if (newHeight >= height) {
    // setElevatorRefrences(newHeight - height);
    // } else {
    // setElevatorRefrences(height - newHeight);
    // }
    // if (newHeight >= elevatorMaxHeight) {
    // setElevatorRefrences(elevatorMaxHeight);
    // } else if (newHeight >= height) {
    // setElevatorRefrences(newHeight - height);
    // } else {
    // setElevatorRefrences(height - newHeight);
    // }

    // }

    // public void topElevator() {
    //     rightPIDController.setReference(ElevatorConstants.topPIDReference, ControlType.kPosition);
    //     leftPIDController.setReference(ElevatorConstants.topPIDReference, ControlType.kPosition);

    //     // is it height that is being set to ElevatorConstants.topPIDReference or like
    //     // our actual setpoint?

    //     setPoint = ElevatorConstants.topPIDReference;
    // }

    // public void bottomElevator() {
    //     rightPIDController.setReference(ElevatorConstants.bottomPIDReference, ControlType.kPosition);
    //     leftPIDController.setReference(ElevatorConstants.bottomPIDReference, ControlType.kPosition);

    // }
    // public void lowElevator() {
    //     rightPIDController.setReference(ElevatorConstants.kBottomPIDReference, ControlType.kPosition);
    //     leftPIDController.setReference(ElevatorConstants.kBottomPIDReference, ControlType.kPosition);

    //     setPoint = ElevatorConstants.bottomPIDReference;

    //     // is it height that is being set to ElevatorConstants.bottomPIDReference or
    //     // like our actual setpoint?
    // }

    // public void elevatorObject() {
    //     rightPIDController.setReference(ElevatorConstants.objectPIDRefrence, ControlType.kPosition);
    //     leftPIDController.setReference(ElevatorConstants.objectPIDRefrence, ControlType.kPosition);

    //     setPoint = ElevatorConstants.kHomePIDRefrence;
    // }

    // public void setAscendSpeed() {
    //     motorControllerGroup.set(ElevatorConstants.ascensionSpeed);
    // }

    // public void setDescendSpeed() {
    //     motorControllerGroup.set(ElevatorConstants.descensionSpeed);
    // }

    // public void stopElevator() {
    //     motorControllerGroup.set(ElevatorConstants.stopSpeed);
    // }

    // public boolean rightLimitSwitch() {
    //     return reversedLimitSwitch.isPressed();
    // }

    // public boolean leftLimitSwitch() {
    //     return reversedLimitSwitch.isPressed();
    // }

    // public boolean isAtSetPoint() {
    //     return Math.abs(setPoint - leftEncoder.getPosition()) <= ElevatorConstants.kLeftPIDTolerance
    //             && Math.abs(setPoint - rightEncoder.getPosition()) <= ElevatorConstants.kRightPIDTolerance;
    // }

    // public void setHome() {
    //     leftEncoder.setPosition(0.0);
    //     rightEncoder.setPosition(0.0);
    // }

    
    //We won't be using PID for elevator, using joystick input to determine height  
    public void setElevatorPower(double power) {
        motorControllerGroup.set(power);

    }
}