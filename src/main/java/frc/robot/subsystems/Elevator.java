// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import frc.robot.Constants;
import frc.robot.Constants.ElevatorConstants;
// import frc.robot.commands.*;
import edu.wpi.first.cameraserver.CameraServer;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.revrobotics.CANSparkMax;
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax.ControlType;

import com.revrobotics.SparkMaxLimitSwitch;
import com.revrobotics.CANSparkMax.IdleMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.SparkMaxLimitSwitch.Type;

import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Elevator extends SubsystemBase {

    private final CANSparkMax leftMotor;
    private final CANSparkMax rightMotor;

    private SparkMaxPIDController leftPIDController;
    private SparkMaxPIDController rightPIDController;

    // 1e-6

    private double kP = 1.5;
    private double kI = 0.0001;
    private double kD = 0.000001;
    private double kIz = 0.000001;
    private double kFF = 0;
    private double kMaxOutput = 1;
    private double kMinOutput = -1;

    private double rotations = 0;

    private final double allowedErr = 0.1;

    private RelativeEncoder leftEncoder;
    private RelativeEncoder rightEncoder;

    private double setPoint = 0.0;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    /**
    *
    */
    public Elevator() {

        leftMotor = new CANSparkMax(ElevatorConstants.kLeftMotor, MotorType.kBrushless);
        rightMotor = new CANSparkMax(ElevatorConstants.kRightMotor, MotorType.kBrushless);

        leftMotor.restoreFactoryDefaults();
        rightMotor.restoreFactoryDefaults();

        leftMotor.setIdleMode(IdleMode.kBrake);
        rightMotor.setIdleMode(IdleMode.kBrake);


        leftPIDController = leftMotor.getPIDController();
        rightPIDController = rightMotor.getPIDController();

        leftEncoder = leftMotor.getEncoder();
        rightEncoder = rightMotor.getEncoder();

        leftEncoder.setPosition(0.0);
        rightEncoder.setPosition(0.0);

        leftPIDController.setP(kP);
        leftPIDController.setI(kI);
        leftPIDController.setD(kD);
        leftPIDController.setIZone(kIz);
        leftPIDController.setFF(kFF);
        leftPIDController.setOutputRange(kMinOutput, kMaxOutput);

        rightPIDController.setP(kP);
        rightPIDController.setI(kI);
        rightPIDController.setD(kD);
        rightPIDController.setIZone(kIz);
        rightPIDController.setFF(kFF);
        rightPIDController.setOutputRange(kMinOutput, kMaxOutput);

        // rightPIDController.setSmartMotionAllowedClosedLoopError(allowedErr, 0);
        // leftPIDController.setSmartMotionAllowedClosedLoopError(allowedErr, 0);

        // reversedLimitSwitch = leftMotor.getReverseLimitSwitch(Type.kNormallyOpen);
        // reversedLimitSwitch.enableLimitSwitch(true);

        // leftEncoder.setPositionFactor(M_PI * 3/4);

        // // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

        // SmartDashboard.putNumber("Elevator Rotations", rotations);
        SmartDashboard.putNumber("Elevator P Gain", kP);
        SmartDashboard.putNumber("Elevator I Gain", kI);
        SmartDashboard.putNumber("Elevator D Gain", kD);
        SmartDashboard.putNumber("Elevator I Zone", kIz);
        SmartDashboard.putNumber("Elevator Feed Forward", kFF);
        SmartDashboard.putNumber("Elevator Max Output", kMaxOutput);
        SmartDashboard.putNumber("Elevator Min Output", kMinOutput);
    }

    @Override
    public void periodic() {
        double p = SmartDashboard.getNumber("Elevator P Gain", 0);
        double i = SmartDashboard.getNumber("Elevator I Gain", 0);
        double d = SmartDashboard.getNumber("Elevator D Gain", 0);
        double iz = SmartDashboard.getNumber("Elevator I Zone", 0);
        double ff = SmartDashboard.getNumber("Elevator Feed Forward", 0);
        double max = SmartDashboard.getNumber("Elevator Max Output", 0);
        double min = SmartDashboard.getNumber("Elevator Min Output", 0);
        // if PID coefficients on SmartDashboard have changed, write new values to
        // controller
        if ((p != kP)) {
            leftPIDController.setP(p);
            rightPIDController.setP(p);
            kP = p;
        }
        if ((i != kI)) {
            leftPIDController.setI(i);
            rightPIDController.setI(i);
            kI = i;
        }
        if ((d != kD)) {
            leftPIDController.setD(d);
            rightPIDController.setD(d);
            kD = d;
        }
        if ((iz != kIz)) {
            leftPIDController.setIZone(iz);
            rightPIDController.setIZone(iz);
            kIz = iz;
        }
        if ((ff != kFF)) {
            leftPIDController.setFF(ff);
            rightPIDController.setFF(ff);
            kFF = ff;
        }
        if ((max != kMaxOutput) || (min != kMinOutput)) {
            leftPIDController.setOutputRange(min, max);
            rightPIDController.setOutputRange(min, max);
            kMinOutput = min;
            kMaxOutput = max;
        }

        SmartDashboard.putNumber("Left Elevator Rotations Graph", leftEncoder.getPosition());
        SmartDashboard.putNumber("Left Elevator Rotations", leftEncoder.getPosition());

        SmartDashboard.putNumber("Right Elevator Rotations Graph", rightEncoder.getPosition());
        SmartDashboard.putNumber("Right Elevator Rotations", rightEncoder.getPosition());

        rotations = SmartDashboard.getNumber("Elevator Rotations", rotations);
        leftPIDController.setReference(rotations, ControlType.kPosition);
        rightPIDController.setReference(rotations, ControlType.kPosition);
        // This method will be called once per scheduler run
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    // measure wheel distance per rotation

    // private void setElevatorRefrences(double setHeight) {
    // leftPIDController.setReference(setHeight, CANSparkMax.ControlType.kPosition);
    // rightPIDController.setReference(setHeight,
    // CANSparkMax.ControlType.kPosition);
    // }

    // public void setElevatorHeight(double newHeight) {
    // if (newHeight >= elevatorMaxHeight) {
    // setElevatorRefrences(elevatorMaxHeight);
    // } else if (newHeight >= height) {
    // setElevatorRefrences(newHeight - height);
    // } else {
    // setElevatorRefrences(height - newHeight);
    // }

    // }

    public void topElevator() {
        rightPIDController.setReference(ElevatorConstants.kTopPIDReference, ControlType.kPosition);
        leftPIDController.setReference(ElevatorConstants.kTopPIDReference, ControlType.kPosition);

        setPoint = ElevatorConstants.kTopPIDReference;
    }

    public void lowElevator() {
        rightPIDController.setReference(ElevatorConstants.kBottomPIDReference, ControlType.kPosition);
        leftPIDController.setReference(ElevatorConstants.kBottomPIDReference, ControlType.kPosition);

        setPoint = ElevatorConstants.kBottomPIDReference;
    }

    public void elevatorHome() {
        rightPIDController.setReference(ElevatorConstants.kHomePIDRefrence, ControlType.kPosition);
        leftPIDController.setReference(ElevatorConstants.kHomePIDRefrence, ControlType.kPosition);

        setPoint = ElevatorConstants.kHomePIDRefrence;
    }

    public boolean isElevatorSetpoint() {
        if (Math.abs(setPoint - leftEncoder.getPosition()) < ElevatorConstants.kPIDTolerance
                && Math.abs(setPoint - rightEncoder.getPosition()) < ElevatorConstants.kPIDTolerance) {
            return true;
        } else {
            return false;
        }
    }

    public void elevatorOff(){
        // leftMotor.set(Constants.kMotorStop);
        // rightMotor.set(Constants.kMotorStop);
    }

}
