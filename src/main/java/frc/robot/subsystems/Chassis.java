// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.RelativeEncoder;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.estimator.DifferentialDrivePoseEstimator;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.math.util.Units;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import java.util.Optional;
import org.photonvision.EstimatedRobotPose;
import org.photonvision.PhotonUtils;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Chassis extends SubsystemBase {

  final double CAMERA_HEIGHT_METERS = Units.inchesToMeters(24);
  final double TARGET_HEIGHT_METERS = Units.feetToMeters(5);
  // Angle between horizontal and the camera.
  final double CAMERA_PITCH_RADIANS = Units.degreesToRadians(0);

  final double GOAL_RANGE_METERS = Units.feetToMeters(3);

  final double LINEAR_P = 0.1;
  final double LINEAR_D = 0.0;
  PIDController forwardController = new PIDController(LINEAR_P, 0, LINEAR_D);

  final double ANGULAR_P = 0.1;
  final double ANGULAR_D = 0.0;
  PIDController turnController = new PIDController(ANGULAR_P, 0, ANGULAR_D);

  private final CANSparkMax kLeftFrontController;
  private final CANSparkMax kRightFrontController;
  private final CANSparkMax kLeftRearController;
  private final CANSparkMax kRightRearController;

  private final RelativeEncoder kLeftFrontEncoder;
  private final RelativeEncoder kRightFrontEncoder;

  private final AnalogGyro kGyro = new AnalogGyro(0);
  private final DifferentialDriveKinematics m_kinematics = new DifferentialDriveKinematics(
    Constants.DriveConstants.kTrackWidth
  );
  private final DifferentialDrivePoseEstimator m_poseEstimator = new DifferentialDrivePoseEstimator(
    m_kinematics,
    kGyro.getRotation2d(),
    0.0,
    0.0,
    new Pose2d()
  );
  private final Vision vision = new Vision();
  private final Field2d fieldSim = new Field2d();

  // set CANId's for the front and rear of both left and right moters

  // private instance variables for the left and right motor controller groups

  private final MotorControllerGroup kLefMotorControllerGroup;
  private final MotorControllerGroup kRightControllerGroup;

  // private final RelativeEncoder kLeftFrontEncoder;
  // private final RelativeEncoder kRightFrontEncoder;

  // commeted out the encoders for the time being

  private final DifferentialDrive kDifferentialDrive;

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  /**
   *
   */
  public Chassis() {
    kGyro.reset();
    // creating the left front and rear Controllers
    kLeftFrontController = new CANSparkMax(1, MotorType.kBrushless);
    kLeftRearController = new CANSparkMax(2, MotorType.kBrushless);

    // creating the right front and rear controllers
    kRightFrontController = new CANSparkMax(3, MotorType.kBrushless);
    kRightRearController = new CANSparkMax(4, MotorType.kBrushless);

    kLefMotorControllerGroup =
      new MotorControllerGroup(kLeftFrontController, kLeftRearController);

    kRightControllerGroup =
      new MotorControllerGroup(kRightFrontController, kRightRearController);

    kDifferentialDrive =
      new DifferentialDrive(kLefMotorControllerGroup, kRightControllerGroup);

    // the left and right groups are setted to differential drive

    kLeftFrontEncoder = kLeftFrontController.getEncoder();
    kRightFrontEncoder = kRightFrontController.getEncoder();

    kLeftFrontEncoder.setPositionConversionFactor(
      Math.PI * Constants.DriveConstants.kWheelDiamater
    );
    kRightFrontEncoder.setPositionConversionFactor(
      Math.PI * Constants.DriveConstants.kWheelDiamater
    );
    SmartDashboard.putData("Field", fieldSim);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
  }

  @Override
  public void periodic() {
    updateOdometry();
    SmartDashboard.putNumber(
      "Left front encoder velocity: ",
      kLeftFrontEncoder.getVelocity()
    );
    SmartDashboard.putNumber(
      "Right front encoder velocity: ",
      kRightFrontEncoder.getVelocity()
    );

    aimAtTarget();
    // This method will be called once per scheduler run
  }

  @Override
  public void simulationPeriodic() {}

  public void arcadeDrive(double xSpeed, double zRotation) {
    kDifferentialDrive.arcadeDrive(xSpeed, zRotation);
    // This method will be called once per scheduler run when in simulation

  }

  // Put methods for controlling this subsystem
  // here. Call these from Commands.
  
  /*Set tank power is deprecated. Try getting a life instead
   * 
   */
  @Deprecated
  public void setTankPower(double d, double u) {
    kDifferentialDrive.tankDrive(d, u);
  }

  private void updateOdometry() {
    m_poseEstimator.update(
      kGyro.getRotation2d(),
      kLeftFrontEncoder.getPosition(),
      kRightFrontEncoder.getPosition()
    );

    // Also apply vision measurements. We use 0.3 seconds in the past as an example
    // -- on
    // a real robot, this must be calculated based either on latency or timestamps.
    Optional<EstimatedRobotPose> result = vision.getEstimatedGlobalPose(
      m_poseEstimator.getEstimatedPosition()
    );

    if (result.isPresent()) {
      EstimatedRobotPose camPose = result.get();
      System.out.println("We have camera pose");
      m_poseEstimator.addVisionMeasurement(
        camPose.estimatedPose.toPose2d(),
        camPose.timestampSeconds
      );
      fieldSim
        .getObject("Cam Est Pos")
        .setPose(camPose.estimatedPose.toPose2d());
    }
  }

  public Pose2d getPose() {
    return m_poseEstimator.getEstimatedPosition();
  }

  public void aimAtTarget() {
    var cameraData = vision.getCameraData();
    double forwardSpeed;
    double rotationSpeed;

    if (cameraData.hasTargets()) {
      double range = PhotonUtils.calculateDistanceToTargetMeters(
        CAMERA_HEIGHT_METERS,
        TARGET_HEIGHT_METERS,
        CAMERA_PITCH_RADIANS,
        Units.degreesToRadians(cameraData.getBestTarget().getPitch())
      );

      System.out.println(cameraData.getBestTarget().getYaw());
      System.out.println(cameraData.getBestTarget().getPitch());

      forwardSpeed = -forwardController.calculate(range, GOAL_RANGE_METERS);
      rotationSpeed =
        -turnController.calculate(cameraData.getBestTarget().getYaw(), 0);

      //Threshold data to prevent robot from being jiggly and turns motors off
      //TODO: add more elses to disable forward or rotation speed
      if (Math.abs(forwardSpeed) <= 0.03 && Math.abs(rotationSpeed) <= 0.03) {
        arcadeDrive(0, 0);
      } else {
        arcadeDrive(forwardSpeed, rotationSpeed);
      }
    }
  }
}
