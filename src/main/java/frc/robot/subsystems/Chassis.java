// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;
import com.revrobotics.RelativeEncoder;
import edu.wpi.first.math.estimator.DifferentialDrivePoseEstimator;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.wpilibj.AnalogGyro;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;
import edu.wpi.first.wpilibj.smartdashboard.Field2d;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;
import java.util.Optional;
import org.photonvision.EstimatedRobotPose;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class Chassis extends SubsystemBase {

  private final CANSparkMax kLeftFrontController;
  private final CANSparkMax kRightFrontController;
  private final CANSparkMax kLeftRearController;
  private final CANSparkMax kRightRearController;

  private final RelativeEncoder kLeftFrontEncoder;
  private final RelativeEncoder kRightFrontEncoder;

  private final AnalogGyro kGyro = new AnalogGyro(0);
  private final DifferentialDriveKinematics m_kinematics = new DifferentialDriveKinematics(
    Constants.DriveConstants.kTrackWidth
  );
  private final DifferentialDrivePoseEstimator m_poseEstimator = new DifferentialDrivePoseEstimator(
    m_kinematics,
    kGyro.getRotation2d(),
    0.0,
    0.0,
    new Pose2d()
  );
  private final Vision vision = new Vision();
  private final Field2d fieldSim = new Field2d();

  // set CANId's for the front and rear of both left and right moters

  // private instance variables for the left and right motor controller groups

  private final MotorControllerGroup kLefMotorControllerGroup;
  private final MotorControllerGroup kRightControllerGroup;

  // private final RelativeEncoder kLeftFrontEncoder;
  // private final RelativeEncoder kRightFrontEncoder;

  // commeted out the encoders for the time being

  private final DifferentialDrive kDifferentialDrive;

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

  // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

  /**
   *
   */
  public Chassis() {
    kGyro.reset();
    // creating the left front and rear Controllers
    kLeftFrontController = new CANSparkMax(1, MotorType.kBrushless);
    kLeftRearController = new CANSparkMax(2, MotorType.kBrushless);

    // creating the right front and rear controllers
    kRightFrontController = new CANSparkMax(3, MotorType.kBrushless);
    kRightRearController = new CANSparkMax(4, MotorType.kBrushless);

    kLefMotorControllerGroup =
      new MotorControllerGroup(kLeftFrontController, kLeftRearController);

    kRightControllerGroup =
      new MotorControllerGroup(kRightFrontController, kRightRearController);

    kDifferentialDrive =
      new DifferentialDrive(kLefMotorControllerGroup, kRightControllerGroup);

    // the left and right groups are setted to differential drive

    kLeftFrontEncoder = kLeftFrontController.getEncoder();
    kRightFrontEncoder = kRightFrontController.getEncoder();

    kLeftFrontEncoder.setPositionConversionFactor(
      Math.PI * Constants.DriveConstants.kWheelDiamater
    );
    kRightFrontEncoder.setPositionConversionFactor(
      Math.PI * Constants.DriveConstants.kWheelDiamater
    );
    SmartDashboard.putData("Field", fieldSim);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
  }

  @Override
  public void periodic() {
    updateOdometry();
    SmartDashboard.putNumber(
      "Left front encoder velocity: ",
      kLeftFrontEncoder.getVelocity()
    );
    SmartDashboard.putNumber(
      "Right front encoder velocity: ",
      kRightFrontEncoder.getVelocity()
    );
    // This method will be called once per scheduler run
  }

  @Override
  public void simulationPeriodic() {}

  // public void arcadeDrive(double xSpeed, double zRotation) {
  // kDifferentialDrive.arcadeDrive(xSpeed, zRotation);
  // // This method will be called once per scheduler run when in simulation

  // }

  // Put methods for controlling this subsystem
  // here. Call these from Commands.

  public void setTankPower(double d, double u) {
    kDifferentialDrive.tankDrive(d, u);
  }

  private void updateOdometry() {
    m_poseEstimator.update(
      kGyro.getRotation2d(),
      kLeftFrontEncoder.getPosition(),
      kRightFrontEncoder.getPosition()
    );

    // Also apply vision measurements. We use 0.3 seconds in the past as an example
    // -- on
    // a real robot, this must be calculated based either on latency or timestamps.
    Optional<EstimatedRobotPose> result = vision.getEstimatedGlobalPose(
      m_poseEstimator.getEstimatedPosition()
    );

    if (result.isPresent()) {
      EstimatedRobotPose camPose = result.get();
      m_poseEstimator.addVisionMeasurement(
        camPose.estimatedPose.toPose2d(),
        camPose.timestampSeconds
      );
      fieldSim
        .getObject("Cam Est Pos")
        .setPose(camPose.estimatedPose.toPose2d());
    }
  }

  public Pose2d getPose() {
    return m_poseEstimator.getEstimatedPosition();
  }
}
